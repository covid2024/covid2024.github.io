<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <title>AR Capture Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            position: fixed;
            width: 100%;
            height: 100%;
            background-color: #111827; /* bg-gray-900 */
        }
        
        /* Screen Containers */
        .screen {
            display: none;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            overflow: hidden;
        }
        .screen.active {
            display: block;
        }

        #ar-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            /* Only prevent touch on the game container */
            touch-action: none;
        }
        
        #video-feed {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: -2;
        }
        
        #three-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        
        #touch-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            background: transparent;
            /* Ensure touch overlay can receive events */
            pointer-events: auto;
            touch-action: none;
        }
        
        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 1rem 2rem;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 12px;
            font-size: 1.5rem;
            text-align: center;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            pointer-events: none;
        }
        
        #debug-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(220, 38, 38, 0.8); /* Red background for errors */
            color: white;
            padding: 8px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 15;
            font-family: monospace;
            max-width: calc(100% - 20px);
            pointer-events: none;
        }
        
        #instructions-popup {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 24px;
            border-radius: 20px;
            font-size: 16px;
            text-align: center;
            z-index: 5;
            max-width: 80%;
            pointer-events: none;
        }

        /* Navigation Bar */
        nav {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px;
            background-color: #1f2937; /* bg-gray-800 */
            display: flex;
            justify-content: space-around;
            align-items: center;
            z-index: 100;
            /* Allow touch events on navigation */
            touch-action: manipulation;
            pointer-events: auto;
        }
        nav .nav-btn {
            background: none;
            border: none;
            color: #9ca3af; /* text-gray-400 */
            cursor: pointer;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: color 0.2s;
            /* Ensure nav buttons work on mobile */
            touch-action: manipulation;
            pointer-events: auto;
            min-width: 44px;
            min-height: 44px;
        }
        nav .nav-btn.active {
            color: #ffffff; /* text-white */
        }
        nav .nav-btn svg {
            width: 24px;
            height: 24px;
        }
        nav .nav-btn span {
            font-size: 12px;
        }

        /* Pokedex Screen */
        #pokedex-screen {
            padding: 20px;
            color: white;
            overflow-y: auto;
            height: calc(100% - 60px);
            /* Allow normal scrolling on pokedex */
            touch-action: pan-y;
        }
        #pokedex-screen h1 {
            font-size: 2rem;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
        }
        .creature-list-item {
            display: flex;
            align-items: center;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            transition: opacity 0.5s;
        }
        .creature-list-item.not-caught {
            opacity: 0.6;
        }
        .creature-list-item img {
            width: 60px;
            height: 60px;
            margin-right: 15px;
            background-color: rgba(0,0,0,0.2);
            border-radius: 8px;
            flex-shrink: 0;
        }
        .creature-info h3 {
            font-size: 1.25rem;
            font-weight: bold;
        }
        .creature-info p.description {
            font-size: 0.9rem;
            color: #d1d5db;
            margin-top: 4px;
            font-style: italic;
        }
         .creature-info p.status {
            font-size: 0.8rem;
            color: #10b981;
            font-weight: bold;
            margin-top: 6px;
        }
        .creature-list-item.not-caught .creature-info p.status {
            color: #9ca3af;
        }

        #reward-notification {
            display: none;
            text-align: center;
            padding: 20px;
            background-color: #10b981;
            border-radius: 12px;
            margin-top: 20px;
        }

        /* Welcome Modal */
        #welcome-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(8px);
        }
        
        #welcome-modal.hidden {
            display: none;
        }
        
        .modal-content {
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            border-radius: 20px;
            padding: 40px 30px;
            max-width: 450px;
            width: 90%;
            position: relative;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .modal-header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .modal-title {
            font-size: 2.2rem;
            font-weight: bold;
            color: #ffffff;
            margin-bottom: 8px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .modal-subtitle {
            font-size: 1.1rem;
            color: #facc15;
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        
        .modal-body {
            color: #e2e8f0;
            line-height: 1.8;
            margin-bottom: 30px;
        }
        
        .modal-body p {
            margin-bottom: 20px;
            font-size: 1rem;
        }
        
        .modal-body p:last-child {
            margin-bottom: 0;
        }
        
        .highlight-text {
            color: #22d3ee;
            font-weight: 600;
        }
        
        .close-button {
            position: absolute;
            top: 15px;
            right: 20px;
            background: rgba(239, 68, 68, 0.2);
            border: 2px solid #ef4444;
            color: #ef4444;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 1.2rem;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .close-button:hover {
            background: rgba(239, 68, 68, 0.3);
            transform: scale(1.1);
        }
        
        .close-button:active {
            transform: scale(0.95);
        }

        /* Instructions Screen */
        #instructions-screen {
            padding: 20px;
            color: white;
            overflow-y: auto;
            height: calc(100% - 60px);
            /* Allow normal scrolling on instructions */
            touch-action: pan-y;
        }
        #instructions-screen h1 {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 1rem;
        }
        #instructions-screen p {
            font-size: 1.1rem;
            line-height: 1.6;
            margin-bottom: 1rem;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-900">

    <!-- Welcome Modal -->
    <div id="welcome-modal">
        <div class="modal-content">
            <button class="close-button" id="close-modal">×</button>
            <div class="modal-header">
                <h1 class="modal-title">Pokemon GO YCC Edition</h1>
                <p class="modal-subtitle">Chào mừng đến với thế giới YCCEMON</p>
            </div>
            <div class="modal-body">
                <p>Hãy bắt đủ <span class="highlight-text">5 YCCEMON</span> để nhận được phần thưởng tại quầy của YCC.</p>
                <p>Các YCCEMON sẽ xuất hiện tại các địa điểm nhất định và trong thời gian giới hạn, <span class="highlight-text">vuốt màn hình</span> để ném bóng.</p>
                <p>Mỗi YCCEMON tượng trưng cho một phân ban của CLB, khi bắt được bạn sẽ có thể xem được các <span class="highlight-text">thông tin, hoạt động</span> của phân ban trong CLB.</p>
            </div>
        </div>
    </div>

    <div id="game-screen" class="screen active">
        <div id="ar-container">
            <video id="video-feed" playsinline autoplay muted></video>
            <canvas id="three-canvas"></canvas>
            <div id="touch-overlay"></div>
        </div>
        <div id="message-box"></div>
        <div id="debug-info">Initializing...</div>
        <div id="instructions-popup">👆 Swipe UP to throw the ball!</div>
    </div>

    <div id="pokedex-screen" class="screen">
        <h1>Ycc-Dex</h1>
        <div id="creature-list"></div>
        <div id="reward-notification">
            <p class="font-bold text-lg">Chúc mừng bạn đã bắt đủ số Ycc-emon!</p>
            <p>Hãy đến quầy Ycc để nhận quà của bạn.</p>
        </div>
    </div>

    <div id="instructions-screen" class="screen">
        <h1>Hướng dẫn chơi</h1>
        <p><strong>Mục tiêu:</strong> Bắt tất cả 5 sinh vật Ycc-emon xuất hiện trong thế giới thực thông qua camera của bạn.</p>
        <p><strong>1. Tìm sinh vật:</strong> Hướng camera của bạn xung quanh để tìm một Ycc-emon. Chúng sẽ xuất hiện ngẫu nhiên trước mặt bạn.</p>
        <p><strong>2. Ném bóng:</strong> Khi bạn đã sẵn sàng, hãy vuốt lên trên màn hình để ném bóng về phía Ycc-emon.</p>
        <p><strong>3. Bắt giữ:</strong> Nếu quả bóng của bạn ném trúng mục tiêu, bạn sẽ bắt được Ycc-emon! Nó sẽ được ghi nhận vào Ycc-Dex của bạn.</p>
        <p><strong>4. Hoàn thành bộ sưu tập:</strong> Tiếp tục chơi cho đến khi bạn bắt được tất cả 5 Ycc-emon. Sau khi hoàn thành, bạn sẽ nhận được một thông báo đặc biệt.</p>
        <p>Chúc may mắn!</p>
    </div>

    <nav>
        <button id="nav-pokedex" class="nav-btn">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 5.25h16.5m-16.5 4.5h16.5m-16.5 4.5h16.5m-16.5 4.5h16.5" /></svg>
            <span>Ycc-Dex</span>
        </button>
        <button id="nav-game" class="nav-btn active">
             <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 256 256"><g fill="currentColor"><path d="M128 32a96 96 0 1 0 96 96a96.11 96.11 0 0 0-96-96Zm0 176a80 80 0 1 1 80-80a80.09 80.09 0 0 1-80 80Z"/><path d="M128 120a8 8 0 0 0-8 8a8 8 0 0 0 8 8a8 8 0 0 0 8-8a8 8 0 0 0-8-8Zm-40 4a40 40 0 0 1 80 0h16a56 56 0 0 0-112 0Z"/></g></svg>
        </button>
        <button id="nav-instructions" class="nav-btn">
             <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="m11.25 11.25.041-.02a.75.75 0 0 1 1.063.852l-.708 2.836a.75.75 0 0 0 1.063.853l.041-.021M21 12a9 9 0 1 1-18 0a9 9 0 0 1 18 0Zm-9-3.75h.008v.008H12V8.25Z" /></svg>
            <span>Hướng dẫn</span>
        </button>
    </nav>


    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
      }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';

        // --- UPDATED: Added avatarUrl property ---
        const creatures = [
			{
				"id": 1,
				"name": "Mỹ Quang Kình",
				"description": "Hiện thân của Ban Meddes (Media & Design), nơi hội tụ những tâm hồn sáng tạo và con mắt nghệ thuật. Ban chịu trách nhiệm toàn bộ về mặt hình ảnh của CLB, từ thiết kế poster, quay dựng video, đến chụp những bộ ảnh lung linh trong sự kiện. Meddes chính là người khoác lên YCC một chiếc áo rực rỡ và chuyên nghiệp.",
				"modelUrl": "./models/aqua_sparkle.obj",
				"textureUrl": "./textures/aqua_sparkle.png",
				"avatarUrl": "./avatars/aqua_sparkle.png",
				"scale": 1,
				"caught": false
			},
			{
				"id": 2,
				"name": "Thạch Não Nhân",
				"description": "Đại diện cho Ban Nội dung, được xem là 'bộ não' của CLB. Ban chịu trách nhiệm lên ý tưởng, xây dựng kịch bản và kế hoạch chi tiết cho các sự kiện. Tiểu ban Kỹ thuật trực thuộc cũng đảm bảo hệ thống âm thanh, ánh sáng luôn vận hành hoàn hảo. Nội dung chính là ban kiến tạo nên những chương trình thành công của YCC.",
				"modelUrl": "./models/terra_golem.obj",
				"textureUrl": "./textures/terra_golem.png",
				"avatarUrl": "./avatars/terra_golem.png",
				"scale": 1,
				"caught": false
			},
			{
				"id": 3,
				"name": "Phong Sứ Giả",
				"description": "Là biểu tượng của Ban Quan hệ Công chúng (PR), tiếng nói và gương mặt đại diện cho YCC. Ban có nhiệm vụ quản lý các kênh mạng xã hội, lan tỏa thông tin sự kiện, và xây dựng hình ảnh thân thiện, năng động của CLB đến với mọi người. PR chính là cầu nối đưa YCC đến gần hơn với cộng đồng.",
				"modelUrl": "./models/sky_wing.obj",
				"textureUrl": "./textures/sky_wing.png",
				"avatarUrl": "./avatars/sky_wing.png",
				"scale": 1,
				"caught": false
			},
			{
				"id": 4,
				"name": "Lõi Nham Hậu Cần",
				"description": "Tượng trưng cho Ban Tài chính - Hậu cần, nền tảng vững chắc cho mọi hoạt động. Ban quản lý 'ngân khố', chi tiêu và lo liệu tất cả công tác chuẩn bị từ A-Z như địa điểm, vật dụng... để các sự kiện diễn ra suôn sẻ. Đây là ban hỗ trợ thầm lặng nhưng không thể thiếu.",
				"modelUrl": "./models/magma_crawler.obj",
				"textureUrl": "./textures/magma_crawler.png",
				"avatarUrl": "./avatars/magma_crawler.png",
				"scale": 1,
				"caught": false
			},
			{
				"id": 5,
				"name": "Mộc Linh Đối Ngoại",
				"description": "Hiện thân của Ban Tài chính - Đối ngoại, những nhà ngoại giao tài năng của YCC. Ban có nhiệm vụ tìm kiếm, liên hệ và làm việc với các nhà tài trợ, các đối tác bên ngoài để mang về nguồn lực tài chính và những cơ hội hợp tác quý giá, giúp CLB ngày càng phát triển.",
				"modelUrl": "./models/forest_sprite.obj",
				"textureUrl": "./textures/forest_sprite.png",
				"avatarUrl": "./avatars/forest_sprite.png",
				"scale": 1,
				"caught": false
			}
		];
        let currentCreature = null;
        const loadedModels = {};

        // --- DOM Elements ---
        const video = document.getElementById('video-feed');
        const canvas = document.getElementById('three-canvas');
        const touchOverlay = document.getElementById('touch-overlay');
        const messageBox = document.getElementById('message-box');
        const debugInfo = document.getElementById('debug-info');
        const instructionsPopup = document.getElementById('instructions-popup');

        const screens = document.querySelectorAll('.screen');
        const navButtons = document.querySelectorAll('.nav-btn');
        const creatureListContainer = document.getElementById('creature-list');
        const rewardNotification = document.getElementById('reward-notification');

        // --- Game variables ---
        let scene, camera, renderer;
        let targetObject, ball;
        let isThrowing = false;
        let throwVelocity = new THREE.Vector3();
        let clock = new THREE.Clock();
        let targetVelocity = new THREE.Vector3();
        const movementBounds = { x: 4.5, y: 3.0 };
        let targetBoundingBox, ballBoundingBox;
        let canThrow = true;
        let targetCaptured = false;

        let touchData = {
            startX: 0, startY: 0, endX: 0, endY: 0,
            startTime: 0, endTime: 0, isActive: false
        };

        function updateDebug(text, isError = false) {
            debugInfo.textContent = text;
            debugInfo.style.backgroundColor = isError ? 'rgba(220, 38, 38, 0.8)' : 'rgba(0, 0, 0, 0.7)';
        }

        function showScreen(screenId) {
            screens.forEach(screen => {
                screen.classList.toggle('active', screen.id === screenId);
            });
            navButtons.forEach(btn => {
                btn.classList.toggle('active', btn.id === `nav-${screenId.split('-')[0]}`);
            });
        }

        function setupNavigation() {
            // Close modal functionality
            document.getElementById('close-modal').addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                document.getElementById('welcome-modal').classList.add('hidden');
            });

            // Use click events with proper event handling for navigation
            document.getElementById('nav-game').addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                showScreen('game-screen');
            });
            document.getElementById('nav-pokedex').addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                showScreen('pokedex-screen');
            });
            document.getElementById('nav-instructions').addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                showScreen('instructions-screen');
            });

            // Also add touch events for better mobile support
            document.getElementById('nav-game').addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                showScreen('game-screen');
            });
            document.getElementById('nav-pokedex').addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                showScreen('pokedex-screen');
            });
            document.getElementById('nav-instructions').addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                showScreen('instructions-screen');
            });
        }

        // --- UPDATED: Uses avatarUrl ---
        function updatePokedexUI() {
            creatureListContainer.innerHTML = ''; 
            creatures.forEach(creature => {
                const isCaught = creature.caught;
                const item = document.createElement('div');
                item.className = `creature-list-item ${isCaught ? 'caught' : 'not-caught'}`;
                
                const imageUrl = isCaught ? creature.avatarUrl : 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMiIgaGVpZ2h0PSIzMiIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiNmZmYiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSIxMCI+PC9jaXJjbGU+PHBhdGggZD0iTTkuMDkgOWE1IDUgMCAwIDEgNS44MyA1LjgzTTkuMDkgMTUgTCAxNS45MSAxNSIvPjwvc3ZnPg==';

                item.innerHTML = `
                    <img src="${imageUrl}" alt="${creature.name}">
                    <div class="creature-info">
                        <h3>${creature.name}</h3>
                        <p class="description">${isCaught ? creature.description : 'Capture to reveal details...'}</p>
                        <p class="status">${isCaught ? 'CAPTURED' : 'NOT SEEN YET'}</p>
                    </div>
                `;
                creatureListContainer.appendChild(item);
            });

            const allCaught = creatures.every(c => c.caught);
            if (allCaught) {
                rewardNotification.style.display = 'block';
            }
        }

        async function init() {
            updateDebug("Initializing...");
            setupNavigation();
            updatePokedexUI();
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: 'environment',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });
                video.srcObject = stream;
                await new Promise(resolve => video.onloadedmetadata = resolve);
                updateDebug("Camera ready. Looking for creatures...");
            } catch (err) {
                console.error("Camera Error:", err);
                updateDebug("Camera access failed! Check browser permissions.", true);
            }

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                alpha: true,
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            createTarget();
            createBall();
            setupEventListeners();
            animate();
            
            setTimeout(() => {
                instructionsPopup.style.opacity = '0';
                instructionsPopup.style.transition = 'opacity 1s ease-out';
            }, 5000);
        }
        
        // --- UPDATED: Much better error handling in createTarget ---
        function createTarget() {
            const uncaughtCreatures = creatures.filter(c => !c.caught);
            if (uncaughtCreatures.length === 0) {
                updateDebug("All creatures caught!");
                showMessage("You've caught them all!", 3000);
                if(targetObject) scene.remove(targetObject);
                targetObject = null;
                return;
            }

            currentCreature = uncaughtCreatures[Math.floor(Math.random() * uncaughtCreatures.length)];
            
            if (loadedModels[currentCreature.id]) {
                targetObject = loadedModels[currentCreature.id].clone();
                scene.add(targetObject);
                targetObject.position.set(0, 0, -10);
                targetBoundingBox = new THREE.Box3().setFromObject(targetObject);
                // Increased speed and added random direction changes
                targetVelocity.set((Math.random() - 0.5) * 4, (Math.random() - 0.5) * 4, 0);
                updateDebug(`Spawning ${currentCreature.name}`);
                return;
            }

            const textureLoader = new THREE.TextureLoader();
            const objLoader = new OBJLoader();

            updateDebug(`Loading ${currentCreature.name}...`);
            
            textureLoader.load(currentCreature.textureUrl, 
                (texture) => {
                    // Texture loaded successfully, now load model
                    objLoader.load(currentCreature.modelUrl, 
                        (object) => {
                            // Model loaded successfully
                            updateDebug(`${currentCreature.name} ready!`);
                            
                            object.traverse((child) => {
                                if (child instanceof THREE.Mesh) {
                                    child.material = new THREE.MeshStandardMaterial({ map: texture });
                                }
                            });
                            
                            const scale = currentCreature.scale;
                            object.scale.set(scale, scale, scale);
                            object.position.set(0, 0, -10);
                            
                            loadedModels[currentCreature.id] = object; 
                            targetObject = loadedModels[currentCreature.id].clone();
                            
                            scene.add(targetObject);
                            targetBoundingBox = new THREE.Box3().setFromObject(targetObject);
                            // Much faster initial speed with more variation
                            targetVelocity.set((Math.random() - 0.5) * 8, (Math.random() - 0.5) * 8, 0);
                        },
                        undefined, // onProgress callback not needed
                        (error) => {
                            // On Model Load Error
                            console.error(`ERROR loading MODEL: ${currentCreature.modelUrl}`, error);
                            updateDebug(`MODEL NOT FOUND: ${currentCreature.modelUrl}. Check path & filename.`, true);
                        }
                    );
                },
                undefined, // onProgress callback not needed
                (error) => {
                    // On Texture Load Error
                    console.error(`ERROR loading TEXTURE: ${currentCreature.textureUrl}`, error);
                    updateDebug(`TEXTURE NOT FOUND: ${currentCreature.textureUrl}. Check path & filename.`, true);
                }
            );
        }

        function createBall() {
            const upperGeometry = new THREE.SphereGeometry(0.25, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const lowerGeometry = new THREE.SphereGeometry(0.25, 32, 16, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2);
            ball = new THREE.Group();
            
            ball.add(new THREE.Mesh(upperGeometry, new THREE.MeshStandardMaterial({ color: 0xef4444, roughness: 0.4, metalness: 0.1 })));
            ball.add(new THREE.Mesh(lowerGeometry, new THREE.MeshStandardMaterial({ color: 0xfafafa, roughness: 0.4, metalness: 0.1 })));
            
            const band = new THREE.Mesh( new THREE.CylinderGeometry(0.26, 0.26, 0.08, 32), new THREE.MeshStandardMaterial({ color: 0x212121 }) );
            const button = new THREE.Mesh( new THREE.CylinderGeometry(0.08, 0.08, 0.1, 32), new THREE.MeshStandardMaterial({ color: 0xfafafa }) );
            button.position.z = 0.25;
            
            ball.add(band);
            ball.add(button);
            resetBall();
            scene.add(ball);
            ballBoundingBox = new THREE.Box3().setFromObject(ball);
        }

        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize);
            
            // Only prevent default touch behavior on the touch overlay, not globally
            touchOverlay.addEventListener('touchstart', handleTouchStart, { passive: false });
            touchOverlay.addEventListener('touchmove', (e) => {
                // Prevent scrolling only during touch interaction on game area
                if (touchData.isActive) {
                    e.preventDefault();
                }
            }, { passive: false });
            touchOverlay.addEventListener('touchend', handleTouchEnd, { passive: false });
            touchOverlay.addEventListener('touchcancel', handleTouchEnd, { passive: false });
            
            // Mouse events for desktop testing
            touchOverlay.addEventListener('mousedown', handleMouseDown);
            touchOverlay.addEventListener('mouseup', handleMouseUp);
        }

        function handleTouchStart(e) {
            // Only handle if we're on the game screen
            if (!document.getElementById('game-screen').classList.contains('active')) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            if (!canThrow || targetCaptured || !targetObject) return;
            
            const touch = e.touches[0];
            touchData.startX = touch.clientX;
            touchData.startY = touch.clientY;
            touchData.startTime = Date.now();
            touchData.isActive = true;
            
            updateDebug("Touch started - ready to throw");
        }

        function handleTouchEnd(e) {
            // Only handle if we're on the game screen
            if (!document.getElementById('game-screen').classList.contains('active')) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            if (!touchData.isActive || !canThrow || targetCaptured || !targetObject) return;
            
            const touch = e.changedTouches[0];
            touchData.endX = touch.clientX;
            touchData.endY = touch.clientY;
            touchData.endTime = Date.now();
            processSwipe();
            touchData.isActive = false;
        }

        function handleMouseDown(e) {
            if (!document.getElementById('game-screen').classList.contains('active')) return;
            if (!canThrow || targetCaptured || !targetObject) return;
            
            touchData.startX = e.clientX;
            touchData.startY = e.clientY;
            touchData.startTime = Date.now();
            touchData.isActive = true;
        }

        function handleMouseUp(e) {
            if (!document.getElementById('game-screen').classList.contains('active')) return;
            if (!touchData.isActive || !canThrow || targetCaptured || !targetObject) return;
            
            touchData.endX = e.clientX;
            touchData.endY = e.clientY;
            touchData.endTime = Date.now();
            processSwipe();
            touchData.isActive = false;
        }

        function processSwipe() {
            const deltaX = touchData.endX - touchData.startX;
            const deltaY = touchData.startY - touchData.endY; 
            const deltaTime = touchData.endTime - touchData.startTime;

            updateDebug(`Swipe: deltaY=${deltaY}, deltaTime=${deltaTime}`);

            if (deltaY > 20 && deltaTime < 1000) {
                const power = Math.min(deltaY / 150, 2.0);
                const sideForce = Math.max(-2, Math.min(2, deltaX / 100));
                throwVelocity.set(sideForce * 6, power * 20, -power * 30);
                isThrowing = true;
                canThrow = false;
                showMessage("🔴 Ball thrown!", 1000);
                updateDebug("Ball thrown successfully!");
            } else {
                showMessage("Swipe UP to throw!", 1500);
                updateDebug("Swipe not detected - try swiping up");
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateTargetMovement(deltaTime) {
            if (!targetObject || targetCaptured) return;
            
            // Move the target
            targetObject.position.add(targetVelocity.clone().multiplyScalar(deltaTime));
            
            // Bounce off walls with significant randomness
            if (Math.abs(targetObject.position.x) > movementBounds.x) { 
                targetVelocity.x *= -1;
                // Big random velocity changes when bouncing
                targetVelocity.y += (Math.random() - 0.5) * 6;
                targetVelocity.x += (Math.random() - 0.5) * 4;
            }
            if (Math.abs(targetObject.position.y) > movementBounds.y) { 
                targetVelocity.y *= -1;
                // Big random velocity changes when bouncing
                targetVelocity.x += (Math.random() - 0.5) * 6;
                targetVelocity.y += (Math.random() - 0.5) * 4;
            }
            
            // Higher speed limit for more chaos
            const maxSpeed = 10;
            if (targetVelocity.length() > maxSpeed) {
                targetVelocity.normalize().multiplyScalar(maxSpeed);
            }
            
            // More frequent and dramatic direction changes
            if (Math.random() < 0.03) { // 3% chance per frame
                targetVelocity.x += (Math.random() - 0.5) * 8;
                targetVelocity.y += (Math.random() - 0.5) * 8;
            }
            
            // Occasional sudden stops and accelerations
            if (Math.random() < 0.005) { // 0.5% chance for sudden stop
                targetVelocity.multiplyScalar(0.1);
            }
            if (Math.random() < 0.005) { // 0.5% chance for sudden burst
                targetVelocity.multiplyScalar(2);
            }
            
            // Much faster and more chaotic rotation
            targetObject.rotation.y += 2.5 * deltaTime;
            targetObject.rotation.x += 1.2 * deltaTime;
            targetObject.rotation.z += 0.8 * deltaTime;
        }

        function updateBall(deltaTime) {
            if (isThrowing) {
                throwVelocity.y -= 35 * deltaTime; // Stronger gravity
                ball.position.add(throwVelocity.clone().multiplyScalar(deltaTime));
                ball.rotation.x -= 3 * deltaTime; // Faster ball rotation
                ballBoundingBox.setFromObject(ball);
                if (targetObject && !targetCaptured && ballBoundingBox.intersectsBox(targetBoundingBox)) {
                    capture();
                }
                if (ball.position.y < -6) { // Ball goes further down before reset
                    isThrowing = false;
                    setTimeout(() => {
                        resetBall();
                        showMessage("Missed! Try again.", 1500);
                        canThrow = true;
                        updateDebug("Ready to throw");
                    }, 800); // Longer delay before next throw
                }
            }
        }

        function capture() {
            isThrowing = false;
            targetCaptured = true;
            if (currentCreature) {
                const creatureInDB = creatures.find(c => c.id === currentCreature.id);
                if (creatureInDB) {
                    creatureInDB.caught = true;
                }
                updatePokedexUI();
                showMessage(`🎉 CAPTURED ${currentCreature.name}!`, 3000);
            } else {
                 showMessage("🎉 CAPTURED!", 3000);
            }
            updateDebug("CAPTURED!");
            let startTime = clock.getElapsedTime();
            const startPos = targetObject.position.clone();
            const startScale = targetObject.scale.clone();
            function animateCapture() {
                const progress = Math.min((clock.getElapsedTime() - startTime) / 1.0, 1.0);
                targetObject.position.lerpVectors(startPos, ball.position, progress);
                targetObject.scale.lerpVectors(startScale, new THREE.Vector3(0.01, 0.01, 0.01), progress);
                if (progress < 1.0) {
                    requestAnimationFrame(animateCapture);
                } else {
                    scene.remove(targetObject);
                    targetObject = null;
                    setTimeout(resetGame, 2000);
                }
            }
            animateCapture();
        }

        function resetBall() {
            ball.position.set(0, -2.5, 0);
            ball.rotation.set(0, 0, 0);
            throwVelocity.set(0, 0, 0);
        }

        function resetGame() {
            resetBall();
            targetCaptured = false;
            canThrow = true;
            createTarget();
            if (creatures.filter(c => !c.caught).length > 0) {
                showMessage("🎯 New creature appeared!", 2000);
            }
        }

        function showMessage(text, duration = 2000) {
            messageBox.textContent = text;
            messageBox.style.opacity = '1';
            setTimeout(() => { 
                messageBox.style.opacity = '0'; 
            }, duration);
        }

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            if (document.getElementById('game-screen').classList.contains('active')) {
                updateTargetMovement(deltaTime);
                updateBall(deltaTime);
                if (targetObject) {
                    targetBoundingBox.setFromObject(targetObject);
                }
                renderer.render(scene, camera);
            }
        }

        init();
    </script>
</body>
</html>